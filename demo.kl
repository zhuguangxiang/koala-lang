

var opt int str

class Foo[T : Foo[str?] & Bar] : Bar[Int?] {
    a T?
}

/*
let NUM1 = 12345678901234567890
let NUM2 = 100
let NUM3 int8 = 200
let NUM4 int8 = 100
let NUM5 int8 = 0x200
let f1 = 1.23
let N int = 1.23
let O1 object = 100
let b = true
let s1 = "hello"
let s2 = "hi"
let s3 = "he\"l\\lo
 world"
let s4 = "æ±‰"

let b2 = false

let ms = """
{
    "key" : "value"
}
"""

let v int = none
*/

/*
if a > b {
    print("hello");
}
[1,2]
(1,)
tuple[int, int]()
{1:2}
{1, 2, 3}
list(1,2,3)
set[int]({1,2,3})
set({1,2})
dict({1: 2})
dict[str, int]()
str("hello")
int(100)
int.abc
//abc.int
range(1,23)
type()
abc(type)
if a > b { print("hello"); }
*/

/*
let v list[int] = [1,2,3]
let m dict[int, int] = {k:v}

array[int8]("hello")
bytes("hello")

type(v)
*/

/*
func new_bytes(v (int | str | list[int8])? = none) bytes {

}

func add(a (int | str)?, b (int | str)) tuple[int, str] {
    if let a1 = a {
        if a1 is int {
            if b is int {

            } else if b is str {

            }
        } else if a1 is str {

        } else {
            unreachable()
        }
    }

    guard let a1 = a else {
        return
    }

    if (a1 is int) {

    }

    arr := [1,2,3]
    t := (1,)
    map := {"hello", 100}
    bs = bytes(100)
}
*/
#
#!
